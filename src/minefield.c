/* minefield.c generated by valac 0.22.1, the Vala compiler
 * generated from minefield.vala, do not modify */

/*
 * Copyright (C) 2011-2012 Robert Ancell
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version. See http://www.gnu.org/copyleft/gpl.html the full text of the
 * license.
 */

#include <glib.h>
#include <glib-object.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <gobject/gvaluecollector.h>


#define TYPE_FLAG_TYPE (flag_type_get_type ())

#define TYPE_LOCATION (location_get_type ())
#define LOCATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOCATION, Location))
#define LOCATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LOCATION, LocationClass))
#define IS_LOCATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOCATION))
#define IS_LOCATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LOCATION))
#define LOCATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LOCATION, LocationClass))

typedef struct _Location Location;
typedef struct _LocationClass LocationClass;
typedef struct _LocationPrivate LocationPrivate;
typedef struct _ParamSpecLocation ParamSpecLocation;

#define TYPE_NEIGHBOUR (neighbour_get_type ())
typedef struct _Neighbour Neighbour;

#define TYPE_MINEFIELD (minefield_get_type ())
#define MINEFIELD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MINEFIELD, Minefield))
#define MINEFIELD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MINEFIELD, MinefieldClass))
#define IS_MINEFIELD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MINEFIELD))
#define IS_MINEFIELD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MINEFIELD))
#define MINEFIELD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MINEFIELD, MinefieldClass))

typedef struct _Minefield Minefield;
typedef struct _MinefieldClass MinefieldClass;
typedef struct _MinefieldPrivate MinefieldPrivate;
#define _g_timer_destroy0(var) ((var == NULL) ? NULL : (var = (g_timer_destroy (var), NULL)))
#define _location_unref0(var) ((var == NULL) ? NULL : (var = (location_unref (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
typedef struct _ParamSpecMinefield ParamSpecMinefield;

typedef enum  {
	FLAG_TYPE_NONE,
	FLAG_TYPE_FLAG,
	FLAG_TYPE_MAYBE
} FlagType;

struct _Location {
	GTypeInstance parent_instance;
	volatile int ref_count;
	LocationPrivate * priv;
	gboolean has_mine;
	gboolean cleared;
	FlagType flag;
};

struct _LocationClass {
	GTypeClass parent_class;
	void (*finalize) (Location *self);
};

struct _ParamSpecLocation {
	GParamSpec parent_instance;
};

struct _Neighbour {
	gint x;
	gint y;
};

struct _Minefield {
	GTypeInstance parent_instance;
	volatile int ref_count;
	MinefieldPrivate * priv;
	guint width;
	guint height;
	guint n_mines;
	gboolean exploded;
};

struct _MinefieldClass {
	GTypeClass parent_class;
	void (*finalize) (Minefield *self);
};

struct _MinefieldPrivate {
	Location** locations;
	gint locations_length1;
	gint locations_length2;
	gboolean placed_mines;
	guint _n_cleared;
	guint _n_flags;
	gdouble clock_elapsed;
	GTimer* clock;
	guint clock_timeout;
	gboolean _paused;
};

struct _ParamSpecMinefield {
	GParamSpec parent_instance;
};


static gpointer location_parent_class = NULL;
static gpointer minefield_parent_class = NULL;

GType flag_type_get_type (void) G_GNUC_CONST;
gpointer location_ref (gpointer instance);
void location_unref (gpointer instance);
GParamSpec* param_spec_location (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_location (GValue* value, gpointer v_object);
void value_take_location (GValue* value, gpointer v_object);
gpointer value_get_location (const GValue* value);
GType location_get_type (void) G_GNUC_CONST;
enum  {
	LOCATION_DUMMY_PROPERTY
};
Location* location_new (void);
Location* location_construct (GType object_type);
static void location_finalize (Location* obj);
GType neighbour_get_type (void) G_GNUC_CONST;
Neighbour* neighbour_dup (const Neighbour* self);
void neighbour_free (Neighbour* self);
gpointer minefield_ref (gpointer instance);
void minefield_unref (gpointer instance);
GParamSpec* param_spec_minefield (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_minefield (GValue* value, gpointer v_object);
void value_take_minefield (GValue* value, gpointer v_object);
gpointer value_get_minefield (const GValue* value);
GType minefield_get_type (void) G_GNUC_CONST;
#define MINEFIELD_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MINEFIELD, MinefieldPrivate))
enum  {
	MINEFIELD_DUMMY_PROPERTY
};
Minefield* minefield_new (guint width, guint height, guint n_mines);
Minefield* minefield_construct (GType object_type, guint width, guint height, guint n_mines);
gboolean minefield_has_mine (Minefield* self, guint x, guint y);
gboolean minefield_is_cleared (Minefield* self, guint x, guint y);
gboolean minefield_is_location (Minefield* self, gint x, gint y);
void minefield_clear_mine (Minefield* self, guint x, guint y);
static void minefield_start_clock (Minefield* self);
static void minefield_place_mines (Minefield* self, guint x, guint y);
static void minefield_clear_mines_recursive (Minefield* self, guint x, guint y);
static void minefield_stop_clock (Minefield* self);
gboolean minefield_get_is_complete (Minefield* self);
void minefield_set_flag (Minefield* self, guint x, guint y, FlagType flag);
guint minefield_get_n_cleared (Minefield* self);
void minefield_set_n_cleared (Minefield* self, guint value);
guint minefield_get_n_flags (Minefield* self);
void minefield_set_n_flags (Minefield* self, guint value);
guint minefield_get_n_adjacent_mines (Minefield* self, guint x, guint y);
FlagType minefield_get_flag (Minefield* self, guint x, guint y);
void minefield_hint (Minefield* self);
gboolean minefield_has_flag_warning (Minefield* self, guint x, guint y);
static gboolean minefield_timeout_cb (Minefield* self);
static void minefield_continue_clock (Minefield* self);
static gboolean _minefield_timeout_cb_gsource_func (gpointer self);
void minefield_auto_play (Minefield* self);
gdouble minefield_get_elapsed (Minefield* self);
gboolean minefield_get_paused (Minefield* self);
void minefield_set_paused (Minefield* self, gboolean value);
static void g_cclosure_user_marshal_VOID__UINT_UINT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void minefield_finalize (Minefield* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

const Neighbour neighbour_map[8] = {{-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {-1, 0}};

GType flag_type_get_type (void) {
	static volatile gsize flag_type_type_id__volatile = 0;
	if (g_once_init_enter (&flag_type_type_id__volatile)) {
		static const GEnumValue values[] = {{FLAG_TYPE_NONE, "FLAG_TYPE_NONE", "none"}, {FLAG_TYPE_FLAG, "FLAG_TYPE_FLAG", "flag"}, {FLAG_TYPE_MAYBE, "FLAG_TYPE_MAYBE", "maybe"}, {0, NULL, NULL}};
		GType flag_type_type_id;
		flag_type_type_id = g_enum_register_static ("FlagType", values);
		g_once_init_leave (&flag_type_type_id__volatile, flag_type_type_id);
	}
	return flag_type_type_id__volatile;
}


Location* location_construct (GType object_type) {
	Location* self = NULL;
	self = (Location*) g_type_create_instance (object_type);
	return self;
}


Location* location_new (void) {
	return location_construct (TYPE_LOCATION);
}


static void value_location_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_location_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		location_unref (value->data[0].v_pointer);
	}
}


static void value_location_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = location_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_location_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_location_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Location* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = location_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_location_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Location** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = location_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_location (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecLocation* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_LOCATION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_location (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_LOCATION), NULL);
	return value->data[0].v_pointer;
}


void value_set_location (GValue* value, gpointer v_object) {
	Location* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_LOCATION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_LOCATION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		location_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		location_unref (old);
	}
}


void value_take_location (GValue* value, gpointer v_object) {
	Location* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_LOCATION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_LOCATION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		location_unref (old);
	}
}


static void location_class_init (LocationClass * klass) {
	location_parent_class = g_type_class_peek_parent (klass);
	LOCATION_CLASS (klass)->finalize = location_finalize;
}


static void location_instance_init (Location * self) {
	self->has_mine = FALSE;
	self->cleared = FALSE;
	self->flag = FLAG_TYPE_NONE;
	self->ref_count = 1;
}


static void location_finalize (Location* obj) {
	Location * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_LOCATION, Location);
}


GType location_get_type (void) {
	static volatile gsize location_type_id__volatile = 0;
	if (g_once_init_enter (&location_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_location_init, value_location_free_value, value_location_copy_value, value_location_peek_pointer, "p", value_location_collect_value, "p", value_location_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (LocationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) location_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Location), 0, (GInstanceInitFunc) location_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType location_type_id;
		location_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Location", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&location_type_id__volatile, location_type_id);
	}
	return location_type_id__volatile;
}


gpointer location_ref (gpointer instance) {
	Location* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void location_unref (gpointer instance) {
	Location* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		LOCATION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


Neighbour* neighbour_dup (const Neighbour* self) {
	Neighbour* dup;
	dup = g_new0 (Neighbour, 1);
	memcpy (dup, self, sizeof (Neighbour));
	return dup;
}


void neighbour_free (Neighbour* self) {
	g_free (self);
}


GType neighbour_get_type (void) {
	static volatile gsize neighbour_type_id__volatile = 0;
	if (g_once_init_enter (&neighbour_type_id__volatile)) {
		GType neighbour_type_id;
		neighbour_type_id = g_boxed_type_register_static ("Neighbour", (GBoxedCopyFunc) neighbour_dup, (GBoxedFreeFunc) neighbour_free);
		g_once_init_leave (&neighbour_type_id__volatile, neighbour_type_id);
	}
	return neighbour_type_id__volatile;
}


Minefield* minefield_construct (GType object_type, guint width, guint height, guint n_mines) {
	Minefield* self = NULL;
	guint _tmp0_ = 0U;
	guint _tmp1_ = 0U;
	Location** _tmp2_ = NULL;
	guint _tmp18_ = 0U;
	guint _tmp19_ = 0U;
	guint _tmp20_ = 0U;
	self = (Minefield*) g_type_create_instance (object_type);
	_tmp0_ = width;
	_tmp1_ = height;
	_tmp2_ = g_new0 (Location*, (_tmp0_ * _tmp1_) + 1);
	self->priv->locations = (_vala_array_free (self->priv->locations, self->priv->locations_length1 * self->priv->locations_length2, (GDestroyNotify) location_unref), NULL);
	self->priv->locations = _tmp2_;
	self->priv->locations_length1 = _tmp0_;
	self->priv->locations_length2 = _tmp1_;
	{
		gint x = 0;
		x = 0;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_ = FALSE;
				gint _tmp6_ = 0;
				guint _tmp7_ = 0U;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gint _tmp5_ = 0;
					_tmp5_ = x;
					x = _tmp5_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp6_ = x;
				_tmp7_ = width;
				if (!(((guint) _tmp6_) < _tmp7_)) {
					break;
				}
				{
					gint y = 0;
					y = 0;
					{
						gboolean _tmp8_ = FALSE;
						_tmp8_ = TRUE;
						while (TRUE) {
							gboolean _tmp9_ = FALSE;
							gint _tmp11_ = 0;
							guint _tmp12_ = 0U;
							Location** _tmp13_ = NULL;
							gint _tmp13__length1 = 0;
							gint _tmp13__length2 = 0;
							gint _tmp14_ = 0;
							gint _tmp15_ = 0;
							Location* _tmp16_ = NULL;
							Location* _tmp17_ = NULL;
							_tmp9_ = _tmp8_;
							if (!_tmp9_) {
								gint _tmp10_ = 0;
								_tmp10_ = y;
								y = _tmp10_ + 1;
							}
							_tmp8_ = FALSE;
							_tmp11_ = y;
							_tmp12_ = height;
							if (!(((guint) _tmp11_) < _tmp12_)) {
								break;
							}
							_tmp13_ = self->priv->locations;
							_tmp13__length1 = self->priv->locations_length1;
							_tmp13__length2 = self->priv->locations_length2;
							_tmp14_ = x;
							_tmp15_ = y;
							_tmp16_ = location_new ();
							_location_unref0 (_tmp13_[(_tmp14_ * _tmp13__length2) + _tmp15_]);
							_tmp13_[(_tmp14_ * _tmp13__length2) + _tmp15_] = _tmp16_;
							_tmp17_ = _tmp13_[(_tmp14_ * _tmp13__length2) + _tmp15_];
						}
					}
				}
			}
		}
	}
	_tmp18_ = width;
	self->width = _tmp18_;
	_tmp19_ = height;
	self->height = _tmp19_;
	_tmp20_ = n_mines;
	self->n_mines = _tmp20_;
	return self;
}


Minefield* minefield_new (guint width, guint height, guint n_mines) {
	return minefield_construct (TYPE_MINEFIELD, width, height, n_mines);
}


gboolean minefield_has_mine (Minefield* self, guint x, guint y) {
	gboolean result = FALSE;
	Location** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp0__length2 = 0;
	guint _tmp1_ = 0U;
	guint _tmp2_ = 0U;
	Location* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->locations;
	_tmp0__length1 = self->priv->locations_length1;
	_tmp0__length2 = self->priv->locations_length2;
	_tmp1_ = x;
	_tmp2_ = y;
	_tmp3_ = _tmp0_[(_tmp1_ * _tmp0__length2) + _tmp2_];
	_tmp4_ = _tmp3_->has_mine;
	result = _tmp4_;
	return result;
}


gboolean minefield_is_cleared (Minefield* self, guint x, guint y) {
	gboolean result = FALSE;
	Location** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp0__length2 = 0;
	guint _tmp1_ = 0U;
	guint _tmp2_ = 0U;
	Location* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->locations;
	_tmp0__length1 = self->priv->locations_length1;
	_tmp0__length2 = self->priv->locations_length2;
	_tmp1_ = x;
	_tmp2_ = y;
	_tmp3_ = _tmp0_[(_tmp1_ * _tmp0__length2) + _tmp2_];
	_tmp4_ = _tmp3_->cleared;
	result = _tmp4_;
	return result;
}


gboolean minefield_is_location (Minefield* self, gint x, gint y) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gint _tmp3_ = 0;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp11_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp3_ = x;
	if (_tmp3_ >= 0) {
		gint _tmp4_ = 0;
		_tmp4_ = y;
		_tmp2_ = _tmp4_ >= 0;
	} else {
		_tmp2_ = FALSE;
	}
	_tmp5_ = _tmp2_;
	if (_tmp5_) {
		gint _tmp6_ = 0;
		guint _tmp7_ = 0U;
		_tmp6_ = x;
		_tmp7_ = self->width;
		_tmp1_ = ((guint) _tmp6_) < _tmp7_;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp8_ = _tmp1_;
	if (_tmp8_) {
		gint _tmp9_ = 0;
		guint _tmp10_ = 0U;
		_tmp9_ = y;
		_tmp10_ = self->height;
		_tmp0_ = ((guint) _tmp9_) < _tmp10_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp11_ = _tmp0_;
	result = _tmp11_;
	return result;
}


void minefield_clear_mine (Minefield* self, guint x, guint y) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp3_ = FALSE;
	Location** _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	gint _tmp4__length2 = 0;
	guint _tmp5_ = 0U;
	guint _tmp6_ = 0U;
	Location* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp14_ = FALSE;
	guint _tmp15_ = 0U;
	guint _tmp16_ = 0U;
	Location** _tmp17_ = NULL;
	gint _tmp17__length1 = 0;
	gint _tmp17__length2 = 0;
	guint _tmp18_ = 0U;
	guint _tmp19_ = 0U;
	Location* _tmp20_ = NULL;
	gboolean _tmp21_ = FALSE;
	gboolean _tmp23_ = FALSE;
	gboolean _tmp24_ = FALSE;
	g_return_if_fail (self != NULL);
	minefield_start_clock (self);
	_tmp0_ = self->priv->placed_mines;
	if (!_tmp0_) {
		guint _tmp1_ = 0U;
		guint _tmp2_ = 0U;
		_tmp1_ = x;
		_tmp2_ = y;
		minefield_place_mines (self, _tmp1_, _tmp2_);
		self->priv->placed_mines = TRUE;
	}
	_tmp4_ = self->priv->locations;
	_tmp4__length1 = self->priv->locations_length1;
	_tmp4__length2 = self->priv->locations_length2;
	_tmp5_ = x;
	_tmp6_ = y;
	_tmp7_ = _tmp4_[(_tmp5_ * _tmp4__length2) + _tmp6_];
	_tmp8_ = _tmp7_->cleared;
	if (_tmp8_) {
		_tmp3_ = TRUE;
	} else {
		Location** _tmp9_ = NULL;
		gint _tmp9__length1 = 0;
		gint _tmp9__length2 = 0;
		guint _tmp10_ = 0U;
		guint _tmp11_ = 0U;
		Location* _tmp12_ = NULL;
		FlagType _tmp13_ = 0;
		_tmp9_ = self->priv->locations;
		_tmp9__length1 = self->priv->locations_length1;
		_tmp9__length2 = self->priv->locations_length2;
		_tmp10_ = x;
		_tmp11_ = y;
		_tmp12_ = _tmp9_[(_tmp10_ * _tmp9__length2) + _tmp11_];
		_tmp13_ = _tmp12_->flag;
		_tmp3_ = _tmp13_ == FLAG_TYPE_FLAG;
	}
	_tmp14_ = _tmp3_;
	if (_tmp14_) {
		return;
	}
	_tmp15_ = x;
	_tmp16_ = y;
	minefield_clear_mines_recursive (self, _tmp15_, _tmp16_);
	_tmp17_ = self->priv->locations;
	_tmp17__length1 = self->priv->locations_length1;
	_tmp17__length2 = self->priv->locations_length2;
	_tmp18_ = x;
	_tmp19_ = y;
	_tmp20_ = _tmp17_[(_tmp18_ * _tmp17__length2) + _tmp19_];
	_tmp21_ = _tmp20_->has_mine;
	if (_tmp21_) {
		gboolean _tmp22_ = FALSE;
		_tmp22_ = self->exploded;
		if (!_tmp22_) {
			self->exploded = TRUE;
			minefield_stop_clock (self);
			g_signal_emit_by_name (self, "explode");
		}
		return;
	}
	_tmp23_ = minefield_get_is_complete (self);
	_tmp24_ = _tmp23_;
	if (_tmp24_) {
		minefield_stop_clock (self);
		{
			gint tx = 0;
			tx = 0;
			{
				gboolean _tmp25_ = FALSE;
				_tmp25_ = TRUE;
				while (TRUE) {
					gboolean _tmp26_ = FALSE;
					gint _tmp28_ = 0;
					guint _tmp29_ = 0U;
					_tmp26_ = _tmp25_;
					if (!_tmp26_) {
						gint _tmp27_ = 0;
						_tmp27_ = tx;
						tx = _tmp27_ + 1;
					}
					_tmp25_ = FALSE;
					_tmp28_ = tx;
					_tmp29_ = self->width;
					if (!(((guint) _tmp28_) < _tmp29_)) {
						break;
					}
					{
						gint ty = 0;
						ty = 0;
						{
							gboolean _tmp30_ = FALSE;
							_tmp30_ = TRUE;
							while (TRUE) {
								gboolean _tmp31_ = FALSE;
								gint _tmp33_ = 0;
								guint _tmp34_ = 0U;
								gint _tmp35_ = 0;
								gint _tmp36_ = 0;
								gboolean _tmp37_ = FALSE;
								_tmp31_ = _tmp30_;
								if (!_tmp31_) {
									gint _tmp32_ = 0;
									_tmp32_ = ty;
									ty = _tmp32_ + 1;
								}
								_tmp30_ = FALSE;
								_tmp33_ = ty;
								_tmp34_ = self->height;
								if (!(((guint) _tmp33_) < _tmp34_)) {
									break;
								}
								_tmp35_ = tx;
								_tmp36_ = ty;
								_tmp37_ = minefield_has_mine (self, (guint) _tmp35_, (guint) _tmp36_);
								if (_tmp37_) {
									gint _tmp38_ = 0;
									gint _tmp39_ = 0;
									_tmp38_ = tx;
									_tmp39_ = ty;
									minefield_set_flag (self, (guint) _tmp38_, (guint) _tmp39_, FLAG_TYPE_FLAG);
								}
							}
						}
					}
				}
			}
		}
		g_signal_emit_by_name (self, "cleared");
	}
}


static void minefield_clear_mines_recursive (Minefield* self, guint x, guint y) {
	Location** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp0__length2 = 0;
	guint _tmp1_ = 0U;
	guint _tmp2_ = 0U;
	Location* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	Location** _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	gint _tmp5__length2 = 0;
	guint _tmp6_ = 0U;
	guint _tmp7_ = 0U;
	Location* _tmp8_ = NULL;
	guint _tmp9_ = 0U;
	guint _tmp10_ = 0U;
	Location** _tmp11_ = NULL;
	gint _tmp11__length1 = 0;
	gint _tmp11__length2 = 0;
	guint _tmp12_ = 0U;
	guint _tmp13_ = 0U;
	Location* _tmp14_ = NULL;
	FlagType _tmp15_ = 0;
	Location** _tmp18_ = NULL;
	gint _tmp18__length1 = 0;
	gint _tmp18__length2 = 0;
	guint _tmp19_ = 0U;
	guint _tmp20_ = 0U;
	Location* _tmp21_ = NULL;
	guint _tmp22_ = 0U;
	guint _tmp23_ = 0U;
	gboolean _tmp24_ = FALSE;
	Location** _tmp25_ = NULL;
	gint _tmp25__length1 = 0;
	gint _tmp25__length2 = 0;
	guint _tmp26_ = 0U;
	guint _tmp27_ = 0U;
	Location* _tmp28_ = NULL;
	gboolean _tmp29_ = FALSE;
	gboolean _tmp33_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->locations;
	_tmp0__length1 = self->priv->locations_length1;
	_tmp0__length2 = self->priv->locations_length2;
	_tmp1_ = x;
	_tmp2_ = y;
	_tmp3_ = _tmp0_[(_tmp1_ * _tmp0__length2) + _tmp2_];
	_tmp4_ = _tmp3_->cleared;
	if (_tmp4_) {
		return;
	}
	_tmp5_ = self->priv->locations;
	_tmp5__length1 = self->priv->locations_length1;
	_tmp5__length2 = self->priv->locations_length2;
	_tmp6_ = x;
	_tmp7_ = y;
	_tmp8_ = _tmp5_[(_tmp6_ * _tmp5__length2) + _tmp7_];
	_tmp8_->cleared = TRUE;
	_tmp9_ = minefield_get_n_cleared (self);
	_tmp10_ = _tmp9_;
	minefield_set_n_cleared (self, _tmp10_ + 1);
	_tmp11_ = self->priv->locations;
	_tmp11__length1 = self->priv->locations_length1;
	_tmp11__length2 = self->priv->locations_length2;
	_tmp12_ = x;
	_tmp13_ = y;
	_tmp14_ = _tmp11_[(_tmp12_ * _tmp11__length2) + _tmp13_];
	_tmp15_ = _tmp14_->flag;
	if (_tmp15_ == FLAG_TYPE_FLAG) {
		guint _tmp16_ = 0U;
		guint _tmp17_ = 0U;
		_tmp16_ = minefield_get_n_flags (self);
		_tmp17_ = _tmp16_;
		minefield_set_n_flags (self, _tmp17_ - 1);
	}
	_tmp18_ = self->priv->locations;
	_tmp18__length1 = self->priv->locations_length1;
	_tmp18__length2 = self->priv->locations_length2;
	_tmp19_ = x;
	_tmp20_ = y;
	_tmp21_ = _tmp18_[(_tmp19_ * _tmp18__length2) + _tmp20_];
	_tmp21_->flag = FLAG_TYPE_NONE;
	_tmp22_ = x;
	_tmp23_ = y;
	g_signal_emit_by_name (self, "redraw-sector", _tmp22_, _tmp23_);
	g_signal_emit_by_name (self, "marks-changed");
	_tmp25_ = self->priv->locations;
	_tmp25__length1 = self->priv->locations_length1;
	_tmp25__length2 = self->priv->locations_length2;
	_tmp26_ = x;
	_tmp27_ = y;
	_tmp28_ = _tmp25_[(_tmp26_ * _tmp25__length2) + _tmp27_];
	_tmp29_ = _tmp28_->has_mine;
	if (!_tmp29_) {
		guint _tmp30_ = 0U;
		guint _tmp31_ = 0U;
		guint _tmp32_ = 0U;
		_tmp30_ = x;
		_tmp31_ = y;
		_tmp32_ = minefield_get_n_adjacent_mines (self, _tmp30_, _tmp31_);
		_tmp24_ = _tmp32_ == ((guint) 0);
	} else {
		_tmp24_ = FALSE;
	}
	_tmp33_ = _tmp24_;
	if (_tmp33_) {
		{
			Neighbour* neighbour_collection = NULL;
			gint neighbour_collection_length1 = 0;
			gint _neighbour_collection_size_ = 0;
			gint neighbour_it = 0;
			neighbour_collection = neighbour_map;
			neighbour_collection_length1 = G_N_ELEMENTS (neighbour_map);
			for (neighbour_it = 0; neighbour_it < G_N_ELEMENTS (neighbour_map); neighbour_it = neighbour_it + 1) {
				Neighbour neighbour = {0};
				neighbour = neighbour_collection[neighbour_it];
				{
					gint nx = 0;
					guint _tmp34_ = 0U;
					Neighbour _tmp35_ = {0};
					gint _tmp36_ = 0;
					gint ny = 0;
					guint _tmp37_ = 0U;
					Neighbour _tmp38_ = {0};
					gint _tmp39_ = 0;
					gint _tmp40_ = 0;
					gint _tmp41_ = 0;
					gboolean _tmp42_ = FALSE;
					_tmp34_ = x;
					_tmp35_ = neighbour;
					_tmp36_ = _tmp35_.x;
					nx = ((gint) _tmp34_) + _tmp36_;
					_tmp37_ = y;
					_tmp38_ = neighbour;
					_tmp39_ = _tmp38_.y;
					ny = ((gint) _tmp37_) + _tmp39_;
					_tmp40_ = nx;
					_tmp41_ = ny;
					_tmp42_ = minefield_is_location (self, _tmp40_, _tmp41_);
					if (_tmp42_) {
						gint _tmp43_ = 0;
						gint _tmp44_ = 0;
						_tmp43_ = nx;
						_tmp44_ = ny;
						minefield_clear_mines_recursive (self, (guint) _tmp43_, (guint) _tmp44_);
					}
				}
			}
		}
	}
}


void minefield_set_flag (Minefield* self, guint x, guint y, FlagType flag) {
	gboolean _tmp0_ = FALSE;
	Location** _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	gint _tmp1__length2 = 0;
	guint _tmp2_ = 0U;
	guint _tmp3_ = 0U;
	Location* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp12_ = FALSE;
	FlagType _tmp13_ = 0;
	Location** _tmp23_ = NULL;
	gint _tmp23__length1 = 0;
	gint _tmp23__length2 = 0;
	guint _tmp24_ = 0U;
	guint _tmp25_ = 0U;
	Location* _tmp26_ = NULL;
	FlagType _tmp27_ = 0;
	guint _tmp28_ = 0U;
	guint _tmp29_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp1_ = self->priv->locations;
	_tmp1__length1 = self->priv->locations_length1;
	_tmp1__length2 = self->priv->locations_length2;
	_tmp2_ = x;
	_tmp3_ = y;
	_tmp4_ = _tmp1_[(_tmp2_ * _tmp1__length2) + _tmp3_];
	_tmp5_ = _tmp4_->cleared;
	if (_tmp5_) {
		_tmp0_ = TRUE;
	} else {
		Location** _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		gint _tmp6__length2 = 0;
		guint _tmp7_ = 0U;
		guint _tmp8_ = 0U;
		Location* _tmp9_ = NULL;
		FlagType _tmp10_ = 0;
		FlagType _tmp11_ = 0;
		_tmp6_ = self->priv->locations;
		_tmp6__length1 = self->priv->locations_length1;
		_tmp6__length2 = self->priv->locations_length2;
		_tmp7_ = x;
		_tmp8_ = y;
		_tmp9_ = _tmp6_[(_tmp7_ * _tmp6__length2) + _tmp8_];
		_tmp10_ = _tmp9_->flag;
		_tmp11_ = flag;
		_tmp0_ = _tmp10_ == _tmp11_;
	}
	_tmp12_ = _tmp0_;
	if (_tmp12_) {
		return;
	}
	_tmp13_ = flag;
	if (_tmp13_ == FLAG_TYPE_FLAG) {
		guint _tmp14_ = 0U;
		guint _tmp15_ = 0U;
		_tmp14_ = minefield_get_n_flags (self);
		_tmp15_ = _tmp14_;
		minefield_set_n_flags (self, _tmp15_ + 1);
	} else {
		Location** _tmp16_ = NULL;
		gint _tmp16__length1 = 0;
		gint _tmp16__length2 = 0;
		guint _tmp17_ = 0U;
		guint _tmp18_ = 0U;
		Location* _tmp19_ = NULL;
		FlagType _tmp20_ = 0;
		_tmp16_ = self->priv->locations;
		_tmp16__length1 = self->priv->locations_length1;
		_tmp16__length2 = self->priv->locations_length2;
		_tmp17_ = x;
		_tmp18_ = y;
		_tmp19_ = _tmp16_[(_tmp17_ * _tmp16__length2) + _tmp18_];
		_tmp20_ = _tmp19_->flag;
		if (_tmp20_ == FLAG_TYPE_FLAG) {
			guint _tmp21_ = 0U;
			guint _tmp22_ = 0U;
			_tmp21_ = minefield_get_n_flags (self);
			_tmp22_ = _tmp21_;
			minefield_set_n_flags (self, _tmp22_ - 1);
		}
	}
	_tmp23_ = self->priv->locations;
	_tmp23__length1 = self->priv->locations_length1;
	_tmp23__length2 = self->priv->locations_length2;
	_tmp24_ = x;
	_tmp25_ = y;
	_tmp26_ = _tmp23_[(_tmp24_ * _tmp23__length2) + _tmp25_];
	_tmp27_ = flag;
	_tmp26_->flag = _tmp27_;
	_tmp28_ = x;
	_tmp29_ = y;
	g_signal_emit_by_name (self, "redraw-sector", _tmp28_, _tmp29_);
	{
		Neighbour* neighbour_collection = NULL;
		gint neighbour_collection_length1 = 0;
		gint _neighbour_collection_size_ = 0;
		gint neighbour_it = 0;
		neighbour_collection = neighbour_map;
		neighbour_collection_length1 = G_N_ELEMENTS (neighbour_map);
		for (neighbour_it = 0; neighbour_it < G_N_ELEMENTS (neighbour_map); neighbour_it = neighbour_it + 1) {
			Neighbour neighbour = {0};
			neighbour = neighbour_collection[neighbour_it];
			{
				gint nx = 0;
				guint _tmp30_ = 0U;
				Neighbour _tmp31_ = {0};
				gint _tmp32_ = 0;
				gint ny = 0;
				guint _tmp33_ = 0U;
				Neighbour _tmp34_ = {0};
				gint _tmp35_ = 0;
				gboolean _tmp36_ = FALSE;
				gint _tmp37_ = 0;
				gint _tmp38_ = 0;
				gboolean _tmp39_ = FALSE;
				gboolean _tmp43_ = FALSE;
				_tmp30_ = x;
				_tmp31_ = neighbour;
				_tmp32_ = _tmp31_.x;
				nx = ((gint) _tmp30_) + _tmp32_;
				_tmp33_ = y;
				_tmp34_ = neighbour;
				_tmp35_ = _tmp34_.y;
				ny = ((gint) _tmp33_) + _tmp35_;
				_tmp37_ = nx;
				_tmp38_ = ny;
				_tmp39_ = minefield_is_location (self, _tmp37_, _tmp38_);
				if (_tmp39_) {
					gint _tmp40_ = 0;
					gint _tmp41_ = 0;
					gboolean _tmp42_ = FALSE;
					_tmp40_ = nx;
					_tmp41_ = ny;
					_tmp42_ = minefield_is_cleared (self, (guint) _tmp40_, (guint) _tmp41_);
					_tmp36_ = _tmp42_;
				} else {
					_tmp36_ = FALSE;
				}
				_tmp43_ = _tmp36_;
				if (_tmp43_) {
					gint _tmp44_ = 0;
					gint _tmp45_ = 0;
					_tmp44_ = nx;
					_tmp45_ = ny;
					g_signal_emit_by_name (self, "redraw-sector", (guint) _tmp44_, (guint) _tmp45_);
				}
			}
		}
	}
	g_signal_emit_by_name (self, "marks-changed");
}


FlagType minefield_get_flag (Minefield* self, guint x, guint y) {
	FlagType result = 0;
	Location** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp0__length2 = 0;
	guint _tmp1_ = 0U;
	guint _tmp2_ = 0U;
	Location* _tmp3_ = NULL;
	FlagType _tmp4_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->locations;
	_tmp0__length1 = self->priv->locations_length1;
	_tmp0__length2 = self->priv->locations_length2;
	_tmp1_ = x;
	_tmp2_ = y;
	_tmp3_ = _tmp0_[(_tmp1_ * _tmp0__length2) + _tmp2_];
	_tmp4_ = _tmp3_->flag;
	result = _tmp4_;
	return result;
}


static gpointer _location_ref0 (gpointer self) {
	return self ? location_ref (self) : NULL;
}


void minefield_hint (Minefield* self) {
	GList* case1list = NULL;
	GList* case2list = NULL;
	GList* case3list = NULL;
	guint hint_location = 0U;
	GList* _tmp53_ = NULL;
	guint _tmp54_ = 0U;
	guint x = 0U;
	guint _tmp74_ = 0U;
	guint _tmp75_ = 0U;
	guint y = 0U;
	guint _tmp76_ = 0U;
	guint _tmp77_ = 0U;
	Location** _tmp78_ = NULL;
	gint _tmp78__length1 = 0;
	gint _tmp78__length2 = 0;
	guint _tmp79_ = 0U;
	guint _tmp80_ = 0U;
	Location* _tmp81_ = NULL;
	FlagType _tmp82_ = 0;
	guint _tmp87_ = 0U;
	guint _tmp88_ = 0U;
	gdouble _tmp89_ = 0.0;
	g_return_if_fail (self != NULL);
	case1list = NULL;
	case2list = NULL;
	case3list = NULL;
	{
		gint mx = 0;
		mx = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_ = FALSE;
				gint _tmp3_ = 0;
				guint _tmp4_ = 0U;
				_tmp1_ = _tmp0_;
				if (!_tmp1_) {
					gint _tmp2_ = 0;
					_tmp2_ = mx;
					mx = _tmp2_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp3_ = mx;
				_tmp4_ = self->width;
				if (!(((guint) _tmp3_) < _tmp4_)) {
					break;
				}
				{
					gint my = 0;
					my = 0;
					{
						gboolean _tmp5_ = FALSE;
						_tmp5_ = TRUE;
						while (TRUE) {
							gboolean _tmp6_ = FALSE;
							gint _tmp8_ = 0;
							guint _tmp9_ = 0U;
							Location* m = NULL;
							Location** _tmp10_ = NULL;
							gint _tmp10__length1 = 0;
							gint _tmp10__length2 = 0;
							gint _tmp11_ = 0;
							gint _tmp12_ = 0;
							Location* _tmp13_ = NULL;
							Location* _tmp14_ = NULL;
							gboolean _tmp15_ = FALSE;
							Location* _tmp16_ = NULL;
							gboolean _tmp17_ = FALSE;
							gboolean _tmp20_ = FALSE;
							_tmp6_ = _tmp5_;
							if (!_tmp6_) {
								gint _tmp7_ = 0;
								_tmp7_ = my;
								my = _tmp7_ + 1;
							}
							_tmp5_ = FALSE;
							_tmp8_ = my;
							_tmp9_ = self->height;
							if (!(((guint) _tmp8_) < _tmp9_)) {
								break;
							}
							_tmp10_ = self->priv->locations;
							_tmp10__length1 = self->priv->locations_length1;
							_tmp10__length2 = self->priv->locations_length2;
							_tmp11_ = mx;
							_tmp12_ = my;
							_tmp13_ = _tmp10_[(_tmp11_ * _tmp10__length2) + _tmp12_];
							_tmp14_ = _location_ref0 (_tmp13_);
							m = _tmp14_;
							_tmp16_ = m;
							_tmp17_ = _tmp16_->has_mine;
							if (!_tmp17_) {
								Location* _tmp18_ = NULL;
								gboolean _tmp19_ = FALSE;
								_tmp18_ = m;
								_tmp19_ = _tmp18_->cleared;
								_tmp15_ = !_tmp19_;
							} else {
								_tmp15_ = FALSE;
							}
							_tmp20_ = _tmp15_;
							if (_tmp20_) {
								gint _tmp21_ = 0;
								guint _tmp22_ = 0U;
								gint _tmp23_ = 0;
								gboolean _tmp24_ = FALSE;
								Location* _tmp25_ = NULL;
								FlagType _tmp26_ = 0;
								gboolean _tmp30_ = FALSE;
								_tmp21_ = mx;
								_tmp22_ = self->width;
								_tmp23_ = my;
								case3list = g_list_append (case3list, (gpointer) ((guintptr) ((_tmp21_ * _tmp22_) + _tmp23_)));
								_tmp25_ = m;
								_tmp26_ = _tmp25_->flag;
								if (_tmp26_ != FLAG_TYPE_FLAG) {
									gint _tmp27_ = 0;
									gint _tmp28_ = 0;
									guint _tmp29_ = 0U;
									_tmp27_ = mx;
									_tmp28_ = my;
									_tmp29_ = minefield_get_n_adjacent_mines (self, (guint) _tmp27_, (guint) _tmp28_);
									_tmp24_ = _tmp29_ > ((guint) 0);
								} else {
									_tmp24_ = FALSE;
								}
								_tmp30_ = _tmp24_;
								if (_tmp30_) {
									gint _tmp31_ = 0;
									guint _tmp32_ = 0U;
									gint _tmp33_ = 0;
									_tmp31_ = mx;
									_tmp32_ = self->width;
									_tmp33_ = my;
									case2list = g_list_append (case2list, (gpointer) ((guintptr) ((_tmp31_ * _tmp32_) + _tmp33_)));
									{
										Neighbour* neighbour_collection = NULL;
										gint neighbour_collection_length1 = 0;
										gint _neighbour_collection_size_ = 0;
										gint neighbour_it = 0;
										neighbour_collection = neighbour_map;
										neighbour_collection_length1 = G_N_ELEMENTS (neighbour_map);
										for (neighbour_it = 0; neighbour_it < G_N_ELEMENTS (neighbour_map); neighbour_it = neighbour_it + 1) {
											Neighbour neighbour = {0};
											neighbour = neighbour_collection[neighbour_it];
											{
												gint _tmp34_ = 0;
												Neighbour _tmp35_ = {0};
												gint _tmp36_ = 0;
												gint _tmp37_ = 0;
												Neighbour _tmp38_ = {0};
												gint _tmp39_ = 0;
												gboolean _tmp40_ = FALSE;
												Location** _tmp41_ = NULL;
												gint _tmp41__length1 = 0;
												gint _tmp41__length2 = 0;
												gint _tmp42_ = 0;
												Neighbour _tmp43_ = {0};
												gint _tmp44_ = 0;
												gint _tmp45_ = 0;
												Neighbour _tmp46_ = {0};
												gint _tmp47_ = 0;
												Location* _tmp48_ = NULL;
												gboolean _tmp49_ = FALSE;
												_tmp34_ = mx;
												_tmp35_ = neighbour;
												_tmp36_ = _tmp35_.x;
												_tmp37_ = my;
												_tmp38_ = neighbour;
												_tmp39_ = _tmp38_.y;
												_tmp40_ = minefield_is_location (self, _tmp34_ + _tmp36_, _tmp37_ + _tmp39_);
												if (!_tmp40_) {
													continue;
												}
												_tmp41_ = self->priv->locations;
												_tmp41__length1 = self->priv->locations_length1;
												_tmp41__length2 = self->priv->locations_length2;
												_tmp42_ = mx;
												_tmp43_ = neighbour;
												_tmp44_ = _tmp43_.x;
												_tmp45_ = my;
												_tmp46_ = neighbour;
												_tmp47_ = _tmp46_.y;
												_tmp48_ = _tmp41_[((_tmp42_ + _tmp44_) * _tmp41__length2) + (_tmp45_ + _tmp47_)];
												_tmp49_ = _tmp48_->cleared;
												if (_tmp49_) {
													gint _tmp50_ = 0;
													guint _tmp51_ = 0U;
													gint _tmp52_ = 0;
													_tmp50_ = mx;
													_tmp51_ = self->width;
													_tmp52_ = my;
													case1list = g_list_append (case1list, (gpointer) ((guintptr) ((_tmp50_ * _tmp51_) + _tmp52_)));
													break;
												}
											}
										}
									}
								}
							}
							_location_unref0 (m);
						}
					}
				}
			}
		}
	}
	hint_location = (guint) 0;
	_tmp53_ = case1list;
	_tmp54_ = g_list_length (_tmp53_);
	if (_tmp54_ > ((guint) 0)) {
		GList* _tmp55_ = NULL;
		GList* _tmp56_ = NULL;
		guint _tmp57_ = 0U;
		gint32 _tmp58_ = 0;
		gconstpointer _tmp59_ = NULL;
		_tmp55_ = case1list;
		_tmp56_ = case1list;
		_tmp57_ = g_list_length (_tmp56_);
		_tmp58_ = g_random_int_range ((gint32) 0, (gint32) _tmp57_);
		_tmp59_ = g_list_nth_data (_tmp55_, (guint) _tmp58_);
		hint_location = (guint) ((guintptr) _tmp59_);
	} else {
		GList* _tmp60_ = NULL;
		guint _tmp61_ = 0U;
		_tmp60_ = case2list;
		_tmp61_ = g_list_length (_tmp60_);
		if (_tmp61_ > ((guint) 0)) {
			GList* _tmp62_ = NULL;
			GList* _tmp63_ = NULL;
			guint _tmp64_ = 0U;
			gint32 _tmp65_ = 0;
			gconstpointer _tmp66_ = NULL;
			_tmp62_ = case2list;
			_tmp63_ = case2list;
			_tmp64_ = g_list_length (_tmp63_);
			_tmp65_ = g_random_int_range ((gint32) 0, (gint32) _tmp64_);
			_tmp66_ = g_list_nth_data (_tmp62_, (guint) _tmp65_);
			hint_location = (guint) ((guintptr) _tmp66_);
		} else {
			GList* _tmp67_ = NULL;
			guint _tmp68_ = 0U;
			_tmp67_ = case3list;
			_tmp68_ = g_list_length (_tmp67_);
			if (_tmp68_ > ((guint) 0)) {
				GList* _tmp69_ = NULL;
				GList* _tmp70_ = NULL;
				guint _tmp71_ = 0U;
				gint32 _tmp72_ = 0;
				gconstpointer _tmp73_ = NULL;
				_tmp69_ = case3list;
				_tmp70_ = case3list;
				_tmp71_ = g_list_length (_tmp70_);
				_tmp72_ = g_random_int_range ((gint32) 0, (gint32) _tmp71_);
				_tmp73_ = g_list_nth_data (_tmp69_, (guint) _tmp72_);
				hint_location = (guint) ((guintptr) _tmp73_);
			}
		}
	}
	_tmp74_ = hint_location;
	_tmp75_ = self->width;
	x = _tmp74_ / _tmp75_;
	_tmp76_ = hint_location;
	_tmp77_ = self->width;
	y = _tmp76_ % _tmp77_;
	_tmp78_ = self->priv->locations;
	_tmp78__length1 = self->priv->locations_length1;
	_tmp78__length2 = self->priv->locations_length2;
	_tmp79_ = x;
	_tmp80_ = y;
	_tmp81_ = _tmp78_[(_tmp79_ * _tmp78__length2) + _tmp80_];
	_tmp82_ = _tmp81_->flag;
	if (_tmp82_ == FLAG_TYPE_FLAG) {
		Location** _tmp83_ = NULL;
		gint _tmp83__length1 = 0;
		gint _tmp83__length2 = 0;
		guint _tmp84_ = 0U;
		guint _tmp85_ = 0U;
		Location* _tmp86_ = NULL;
		_tmp83_ = self->priv->locations;
		_tmp83__length1 = self->priv->locations_length1;
		_tmp83__length2 = self->priv->locations_length2;
		_tmp84_ = x;
		_tmp85_ = y;
		_tmp86_ = _tmp83_[(_tmp84_ * _tmp83__length2) + _tmp85_];
		_tmp86_->flag = FLAG_TYPE_NONE;
	}
	_tmp87_ = x;
	_tmp88_ = y;
	minefield_clear_mine (self, _tmp87_, _tmp88_);
	_tmp89_ = self->priv->clock_elapsed;
	self->priv->clock_elapsed = _tmp89_ + 10.0;
	g_signal_emit_by_name (self, "tick");
	_g_list_free0 (case3list);
	_g_list_free0 (case2list);
	_g_list_free0 (case1list);
}


guint minefield_get_n_adjacent_mines (Minefield* self, guint x, guint y) {
	guint result = 0U;
	guint n = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	n = (guint) 0;
	{
		Neighbour* neighbour_collection = NULL;
		gint neighbour_collection_length1 = 0;
		gint _neighbour_collection_size_ = 0;
		gint neighbour_it = 0;
		neighbour_collection = neighbour_map;
		neighbour_collection_length1 = G_N_ELEMENTS (neighbour_map);
		for (neighbour_it = 0; neighbour_it < G_N_ELEMENTS (neighbour_map); neighbour_it = neighbour_it + 1) {
			Neighbour neighbour = {0};
			neighbour = neighbour_collection[neighbour_it];
			{
				gint nx = 0;
				guint _tmp0_ = 0U;
				Neighbour _tmp1_ = {0};
				gint _tmp2_ = 0;
				gint ny = 0;
				guint _tmp3_ = 0U;
				Neighbour _tmp4_ = {0};
				gint _tmp5_ = 0;
				gboolean _tmp6_ = FALSE;
				gint _tmp7_ = 0;
				gint _tmp8_ = 0;
				gboolean _tmp9_ = FALSE;
				gboolean _tmp13_ = FALSE;
				_tmp0_ = x;
				_tmp1_ = neighbour;
				_tmp2_ = _tmp1_.x;
				nx = ((gint) _tmp0_) + _tmp2_;
				_tmp3_ = y;
				_tmp4_ = neighbour;
				_tmp5_ = _tmp4_.y;
				ny = ((gint) _tmp3_) + _tmp5_;
				_tmp7_ = nx;
				_tmp8_ = ny;
				_tmp9_ = minefield_is_location (self, _tmp7_, _tmp8_);
				if (_tmp9_) {
					gint _tmp10_ = 0;
					gint _tmp11_ = 0;
					gboolean _tmp12_ = FALSE;
					_tmp10_ = nx;
					_tmp11_ = ny;
					_tmp12_ = minefield_has_mine (self, (guint) _tmp10_, (guint) _tmp11_);
					_tmp6_ = _tmp12_;
				} else {
					_tmp6_ = FALSE;
				}
				_tmp13_ = _tmp6_;
				if (_tmp13_) {
					guint _tmp14_ = 0U;
					_tmp14_ = n;
					n = _tmp14_ + 1;
				}
			}
		}
	}
	result = n;
	return result;
}


gboolean minefield_has_flag_warning (Minefield* self, guint x, guint y) {
	gboolean result = FALSE;
	guint _tmp0_ = 0U;
	guint _tmp1_ = 0U;
	gboolean _tmp2_ = FALSE;
	guint n_mines = 0U;
	guint n_flags = 0U;
	guint _tmp20_ = 0U;
	guint _tmp21_ = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = x;
	_tmp1_ = y;
	_tmp2_ = minefield_is_cleared (self, _tmp0_, _tmp1_);
	if (!_tmp2_) {
		result = FALSE;
		return result;
	}
	n_mines = (guint) 0;
	n_flags = (guint) 0;
	{
		Neighbour* neighbour_collection = NULL;
		gint neighbour_collection_length1 = 0;
		gint _neighbour_collection_size_ = 0;
		gint neighbour_it = 0;
		neighbour_collection = neighbour_map;
		neighbour_collection_length1 = G_N_ELEMENTS (neighbour_map);
		for (neighbour_it = 0; neighbour_it < G_N_ELEMENTS (neighbour_map); neighbour_it = neighbour_it + 1) {
			Neighbour neighbour = {0};
			neighbour = neighbour_collection[neighbour_it];
			{
				gint nx = 0;
				guint _tmp3_ = 0U;
				Neighbour _tmp4_ = {0};
				gint _tmp5_ = 0;
				gint ny = 0;
				guint _tmp6_ = 0U;
				Neighbour _tmp7_ = {0};
				gint _tmp8_ = 0;
				gint _tmp9_ = 0;
				gint _tmp10_ = 0;
				gboolean _tmp11_ = FALSE;
				gint _tmp12_ = 0;
				gint _tmp13_ = 0;
				gboolean _tmp14_ = FALSE;
				gint _tmp16_ = 0;
				gint _tmp17_ = 0;
				FlagType _tmp18_ = 0;
				_tmp3_ = x;
				_tmp4_ = neighbour;
				_tmp5_ = _tmp4_.x;
				nx = ((gint) _tmp3_) + _tmp5_;
				_tmp6_ = y;
				_tmp7_ = neighbour;
				_tmp8_ = _tmp7_.y;
				ny = ((gint) _tmp6_) + _tmp8_;
				_tmp9_ = nx;
				_tmp10_ = ny;
				_tmp11_ = minefield_is_location (self, _tmp9_, _tmp10_);
				if (!_tmp11_) {
					continue;
				}
				_tmp12_ = nx;
				_tmp13_ = ny;
				_tmp14_ = minefield_has_mine (self, (guint) _tmp12_, (guint) _tmp13_);
				if (_tmp14_) {
					guint _tmp15_ = 0U;
					_tmp15_ = n_mines;
					n_mines = _tmp15_ + 1;
				}
				_tmp16_ = nx;
				_tmp17_ = ny;
				_tmp18_ = minefield_get_flag (self, (guint) _tmp16_, (guint) _tmp17_);
				if (_tmp18_ == FLAG_TYPE_FLAG) {
					guint _tmp19_ = 0U;
					_tmp19_ = n_flags;
					n_flags = _tmp19_ + 1;
				}
			}
		}
	}
	_tmp20_ = n_flags;
	_tmp21_ = n_mines;
	result = _tmp20_ > _tmp21_;
	return result;
}


static void minefield_place_mines (Minefield* self, guint x, guint y) {
	g_return_if_fail (self != NULL);
	{
		gint n = 0;
		n = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_ = FALSE;
				gint _tmp2_ = 0;
				guint _tmp3_ = 0U;
				gint32 rx = 0;
				guint _tmp4_ = 0U;
				gint32 _tmp5_ = 0;
				gint32 ry = 0;
				guint _tmp6_ = 0U;
				gint32 _tmp7_ = 0;
				gboolean _tmp8_ = FALSE;
				gint32 _tmp9_ = 0;
				guint _tmp10_ = 0U;
				gboolean _tmp13_ = FALSE;
				Location** _tmp14_ = NULL;
				gint _tmp14__length1 = 0;
				gint _tmp14__length2 = 0;
				gint32 _tmp15_ = 0;
				gint32 _tmp16_ = 0;
				Location* _tmp17_ = NULL;
				gboolean _tmp18_ = FALSE;
				_tmp1_ = _tmp0_;
				if (!_tmp1_) {
				}
				_tmp0_ = FALSE;
				_tmp2_ = n;
				_tmp3_ = self->n_mines;
				if (!(((guint) _tmp2_) < _tmp3_)) {
					break;
				}
				_tmp4_ = self->width;
				_tmp5_ = g_random_int_range ((gint32) 0, (gint32) _tmp4_);
				rx = _tmp5_;
				_tmp6_ = self->height;
				_tmp7_ = g_random_int_range ((gint32) 0, (gint32) _tmp6_);
				ry = _tmp7_;
				_tmp9_ = rx;
				_tmp10_ = x;
				if (((guint) _tmp9_) == _tmp10_) {
					gint32 _tmp11_ = 0;
					guint _tmp12_ = 0U;
					_tmp11_ = ry;
					_tmp12_ = y;
					_tmp8_ = ((guint) _tmp11_) == _tmp12_;
				} else {
					_tmp8_ = FALSE;
				}
				_tmp13_ = _tmp8_;
				if (_tmp13_) {
					continue;
				}
				_tmp14_ = self->priv->locations;
				_tmp14__length1 = self->priv->locations_length1;
				_tmp14__length2 = self->priv->locations_length2;
				_tmp15_ = rx;
				_tmp16_ = ry;
				_tmp17_ = _tmp14_[(_tmp15_ * _tmp14__length2) + _tmp16_];
				_tmp18_ = _tmp17_->has_mine;
				if (!_tmp18_) {
					gboolean adj_found = FALSE;
					gboolean _tmp29_ = FALSE;
					adj_found = FALSE;
					{
						Neighbour* neighbour_collection = NULL;
						gint neighbour_collection_length1 = 0;
						gint _neighbour_collection_size_ = 0;
						gint neighbour_it = 0;
						neighbour_collection = neighbour_map;
						neighbour_collection_length1 = G_N_ELEMENTS (neighbour_map);
						for (neighbour_it = 0; neighbour_it < G_N_ELEMENTS (neighbour_map); neighbour_it = neighbour_it + 1) {
							Neighbour neighbour = {0};
							neighbour = neighbour_collection[neighbour_it];
							{
								gboolean _tmp19_ = FALSE;
								gint32 _tmp20_ = 0;
								guint _tmp21_ = 0U;
								Neighbour _tmp22_ = {0};
								gint _tmp23_ = 0;
								gboolean _tmp28_ = FALSE;
								_tmp20_ = rx;
								_tmp21_ = x;
								_tmp22_ = neighbour;
								_tmp23_ = _tmp22_.x;
								if (((guint) _tmp20_) == (_tmp21_ + _tmp23_)) {
									gint32 _tmp24_ = 0;
									guint _tmp25_ = 0U;
									Neighbour _tmp26_ = {0};
									gint _tmp27_ = 0;
									_tmp24_ = ry;
									_tmp25_ = y;
									_tmp26_ = neighbour;
									_tmp27_ = _tmp26_.y;
									_tmp19_ = ((guint) _tmp24_) == (_tmp25_ + _tmp27_);
								} else {
									_tmp19_ = FALSE;
								}
								_tmp28_ = _tmp19_;
								if (_tmp28_) {
									adj_found = TRUE;
									break;
								}
							}
						}
					}
					_tmp29_ = adj_found;
					if (!_tmp29_) {
						Location** _tmp30_ = NULL;
						gint _tmp30__length1 = 0;
						gint _tmp30__length2 = 0;
						gint32 _tmp31_ = 0;
						gint32 _tmp32_ = 0;
						Location* _tmp33_ = NULL;
						gint _tmp34_ = 0;
						_tmp30_ = self->priv->locations;
						_tmp30__length1 = self->priv->locations_length1;
						_tmp30__length2 = self->priv->locations_length2;
						_tmp31_ = rx;
						_tmp32_ = ry;
						_tmp33_ = _tmp30_[(_tmp31_ * _tmp30__length2) + _tmp32_];
						_tmp33_->has_mine = TRUE;
						_tmp34_ = n;
						n = _tmp34_ + 1;
					}
				}
			}
		}
	}
}


static void minefield_start_clock (Minefield* self) {
	GTimer* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->clock;
	if (_tmp0_ == NULL) {
		GTimer* _tmp1_ = NULL;
		_tmp1_ = g_timer_new ();
		_g_timer_destroy0 (self->priv->clock);
		self->priv->clock = _tmp1_;
	}
	minefield_timeout_cb (self);
}


static void minefield_stop_clock (Minefield* self) {
	GTimer* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	GTimer* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->clock;
	if (_tmp0_ == NULL) {
		return;
	}
	_tmp1_ = self->priv->clock_timeout;
	if (_tmp1_ != ((guint) 0)) {
		guint _tmp2_ = 0U;
		_tmp2_ = self->priv->clock_timeout;
		g_source_remove (_tmp2_);
	}
	self->priv->clock_timeout = (guint) 0;
	_tmp3_ = self->priv->clock;
	g_timer_stop (_tmp3_);
	g_signal_emit_by_name (self, "tick");
}


static void minefield_continue_clock (Minefield* self) {
	GTimer* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->clock;
	if (_tmp0_ == NULL) {
		GTimer* _tmp1_ = NULL;
		_tmp1_ = g_timer_new ();
		_g_timer_destroy0 (self->priv->clock);
		self->priv->clock = _tmp1_;
	} else {
		GTimer* _tmp2_ = NULL;
		_tmp2_ = self->priv->clock;
		g_timer_continue (_tmp2_);
	}
	minefield_timeout_cb (self);
}


static gboolean _minefield_timeout_cb_gsource_func (gpointer self) {
	gboolean result;
	result = minefield_timeout_cb (self);
	return result;
}


static gboolean minefield_timeout_cb (Minefield* self) {
	gboolean result = FALSE;
	gdouble elapsed = 0.0;
	GTimer* _tmp0_ = NULL;
	gdouble _tmp1_ = 0.0;
	gint next = 0;
	gdouble wait = 0.0;
	guint _tmp2_ = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->clock;
	_tmp1_ = g_timer_elapsed (_tmp0_, NULL);
	elapsed = _tmp1_;
	next = (gint) (elapsed + 1.0);
	wait = next - elapsed;
	_tmp2_ = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) ((gint) (wait * 1000)), _minefield_timeout_cb_gsource_func, minefield_ref (self), minefield_unref);
	self->priv->clock_timeout = _tmp2_;
	g_signal_emit_by_name (self, "tick");
	result = FALSE;
	return result;
}


void minefield_auto_play (Minefield* self) {
	gboolean has_change = FALSE;
	g_return_if_fail (self != NULL);
	has_change = FALSE;
	{
		gboolean _tmp0_ = FALSE;
		_tmp0_ = TRUE;
		while (TRUE) {
			gboolean _tmp1_ = FALSE;
			_tmp1_ = _tmp0_;
			if (!_tmp1_) {
				gboolean _tmp2_ = FALSE;
				_tmp2_ = has_change;
				if (!_tmp2_) {
					break;
				}
			}
			_tmp0_ = FALSE;
			has_change = FALSE;
			{
				guint x = 0U;
				x = (guint) 0;
				{
					gboolean _tmp3_ = FALSE;
					_tmp3_ = TRUE;
					while (TRUE) {
						gboolean _tmp4_ = FALSE;
						guint _tmp6_ = 0U;
						guint _tmp7_ = 0U;
						_tmp4_ = _tmp3_;
						if (!_tmp4_) {
							guint _tmp5_ = 0U;
							_tmp5_ = x;
							x = _tmp5_ + 1;
						}
						_tmp3_ = FALSE;
						_tmp6_ = x;
						_tmp7_ = self->width;
						if (!(_tmp6_ < _tmp7_)) {
							break;
						}
						{
							guint y = 0U;
							y = (guint) 0;
							{
								gboolean _tmp8_ = FALSE;
								_tmp8_ = TRUE;
								while (TRUE) {
									gboolean _tmp9_ = FALSE;
									guint _tmp11_ = 0U;
									guint _tmp12_ = 0U;
									guint _tmp13_ = 0U;
									guint _tmp14_ = 0U;
									gboolean _tmp15_ = FALSE;
									_tmp9_ = _tmp8_;
									if (!_tmp9_) {
										guint _tmp10_ = 0U;
										_tmp10_ = y;
										y = _tmp10_ + 1;
									}
									_tmp8_ = FALSE;
									_tmp11_ = y;
									_tmp12_ = self->height;
									if (!(_tmp11_ < _tmp12_)) {
										break;
									}
									_tmp13_ = x;
									_tmp14_ = y;
									_tmp15_ = minefield_is_cleared (self, _tmp13_, _tmp14_);
									if (_tmp15_) {
										guint empty_space = 0U;
										guint open_space = 0U;
										guint flag_space = 0U;
										guint maybe_space = 0U;
										guint mines = 0U;
										gboolean _tmp39_ = FALSE;
										guint _tmp40_ = 0U;
										gboolean _tmp42_ = FALSE;
										empty_space = (guint) 0;
										open_space = (guint) 0;
										flag_space = (guint) 0;
										maybe_space = (guint) 0;
										mines = (guint) 0;
										{
											Neighbour* neighbour_collection = NULL;
											gint neighbour_collection_length1 = 0;
											gint _neighbour_collection_size_ = 0;
											gint neighbour_it = 0;
											neighbour_collection = neighbour_map;
											neighbour_collection_length1 = G_N_ELEMENTS (neighbour_map);
											for (neighbour_it = 0; neighbour_it < G_N_ELEMENTS (neighbour_map); neighbour_it = neighbour_it + 1) {
												Neighbour neighbour = {0};
												neighbour = neighbour_collection[neighbour_it];
												{
													gint nx = 0;
													guint _tmp16_ = 0U;
													Neighbour _tmp17_ = {0};
													gint _tmp18_ = 0;
													gint ny = 0;
													guint _tmp19_ = 0U;
													Neighbour _tmp20_ = {0};
													gint _tmp21_ = 0;
													gint _tmp22_ = 0;
													gint _tmp23_ = 0;
													gboolean _tmp24_ = FALSE;
													_tmp16_ = x;
													_tmp17_ = neighbour;
													_tmp18_ = _tmp17_.x;
													nx = ((gint) _tmp16_) + _tmp18_;
													_tmp19_ = y;
													_tmp20_ = neighbour;
													_tmp21_ = _tmp20_.y;
													ny = ((gint) _tmp19_) + _tmp21_;
													_tmp22_ = nx;
													_tmp23_ = ny;
													_tmp24_ = minefield_is_location (self, _tmp22_, _tmp23_);
													if (_tmp24_) {
														gint _tmp25_ = 0;
														gint _tmp26_ = 0;
														gboolean _tmp27_ = FALSE;
														_tmp25_ = nx;
														_tmp26_ = ny;
														_tmp27_ = minefield_is_cleared (self, (guint) _tmp25_, (guint) _tmp26_);
														if (!_tmp27_) {
															guint _tmp28_ = 0U;
															gint _tmp29_ = 0;
															gint _tmp30_ = 0;
															FlagType _tmp31_ = 0;
															gint _tmp35_ = 0;
															gint _tmp36_ = 0;
															gboolean _tmp37_ = FALSE;
															_tmp28_ = open_space;
															open_space = _tmp28_ + 1;
															_tmp29_ = nx;
															_tmp30_ = ny;
															_tmp31_ = minefield_get_flag (self, (guint) _tmp29_, (guint) _tmp30_);
															switch (_tmp31_) {
																case FLAG_TYPE_FLAG:
																{
																	guint _tmp32_ = 0U;
																	_tmp32_ = flag_space;
																	flag_space = _tmp32_ + 1;
																	break;
																}
																case FLAG_TYPE_MAYBE:
																{
																	guint _tmp33_ = 0U;
																	_tmp33_ = maybe_space;
																	maybe_space = _tmp33_ + 1;
																	break;
																}
																case FLAG_TYPE_NONE:
																{
																	guint _tmp34_ = 0U;
																	_tmp34_ = empty_space;
																	empty_space = _tmp34_ + 1;
																	break;
																}
																default:
																break;
															}
															_tmp35_ = nx;
															_tmp36_ = ny;
															_tmp37_ = minefield_has_mine (self, (guint) _tmp35_, (guint) _tmp36_);
															if (_tmp37_) {
																guint _tmp38_ = 0U;
																_tmp38_ = mines;
																mines = _tmp38_ + 1;
															}
														}
													}
												}
											}
										}
										_tmp40_ = empty_space;
										if (_tmp40_ > ((guint) 0)) {
											guint _tmp41_ = 0U;
											_tmp41_ = maybe_space;
											_tmp39_ = _tmp41_ == ((guint) 0);
										} else {
											_tmp39_ = FALSE;
										}
										_tmp42_ = _tmp39_;
										if (_tmp42_) {
											guint _tmp43_ = 0U;
											guint _tmp44_ = 0U;
											_tmp43_ = mines;
											_tmp44_ = open_space;
											if (_tmp43_ == _tmp44_) {
												{
													Neighbour* neighbour_collection = NULL;
													gint neighbour_collection_length1 = 0;
													gint _neighbour_collection_size_ = 0;
													gint neighbour_it = 0;
													neighbour_collection = neighbour_map;
													neighbour_collection_length1 = G_N_ELEMENTS (neighbour_map);
													for (neighbour_it = 0; neighbour_it < G_N_ELEMENTS (neighbour_map); neighbour_it = neighbour_it + 1) {
														Neighbour neighbour = {0};
														neighbour = neighbour_collection[neighbour_it];
														{
															gint nx = 0;
															guint _tmp45_ = 0U;
															Neighbour _tmp46_ = {0};
															gint _tmp47_ = 0;
															gint ny = 0;
															guint _tmp48_ = 0U;
															Neighbour _tmp49_ = {0};
															gint _tmp50_ = 0;
															gboolean _tmp51_ = FALSE;
															gint _tmp52_ = 0;
															gint _tmp53_ = 0;
															gboolean _tmp54_ = FALSE;
															gboolean _tmp58_ = FALSE;
															_tmp45_ = x;
															_tmp46_ = neighbour;
															_tmp47_ = _tmp46_.x;
															nx = ((gint) _tmp45_) + _tmp47_;
															_tmp48_ = y;
															_tmp49_ = neighbour;
															_tmp50_ = _tmp49_.y;
															ny = ((gint) _tmp48_) + _tmp50_;
															_tmp52_ = nx;
															_tmp53_ = ny;
															_tmp54_ = minefield_is_location (self, _tmp52_, _tmp53_);
															if (_tmp54_) {
																gint _tmp55_ = 0;
																gint _tmp56_ = 0;
																gboolean _tmp57_ = FALSE;
																_tmp55_ = nx;
																_tmp56_ = ny;
																_tmp57_ = minefield_is_cleared (self, (guint) _tmp55_, (guint) _tmp56_);
																_tmp51_ = !_tmp57_;
															} else {
																_tmp51_ = FALSE;
															}
															_tmp58_ = _tmp51_;
															if (_tmp58_) {
																gint _tmp59_ = 0;
																gint _tmp60_ = 0;
																_tmp59_ = nx;
																_tmp60_ = ny;
																minefield_set_flag (self, (guint) _tmp59_, (guint) _tmp60_, FLAG_TYPE_FLAG);
															}
														}
													}
												}
												has_change = TRUE;
											} else {
												guint _tmp61_ = 0U;
												guint _tmp62_ = 0U;
												_tmp61_ = mines;
												_tmp62_ = flag_space;
												if (_tmp61_ == _tmp62_) {
													{
														Neighbour* neighbour_collection = NULL;
														gint neighbour_collection_length1 = 0;
														gint _neighbour_collection_size_ = 0;
														gint neighbour_it = 0;
														neighbour_collection = neighbour_map;
														neighbour_collection_length1 = G_N_ELEMENTS (neighbour_map);
														for (neighbour_it = 0; neighbour_it < G_N_ELEMENTS (neighbour_map); neighbour_it = neighbour_it + 1) {
															Neighbour neighbour = {0};
															neighbour = neighbour_collection[neighbour_it];
															{
																gint nx = 0;
																guint _tmp63_ = 0U;
																Neighbour _tmp64_ = {0};
																gint _tmp65_ = 0;
																gint ny = 0;
																guint _tmp66_ = 0U;
																Neighbour _tmp67_ = {0};
																gint _tmp68_ = 0;
																gboolean _tmp69_ = FALSE;
																gint _tmp70_ = 0;
																gint _tmp71_ = 0;
																gboolean _tmp72_ = FALSE;
																gboolean _tmp76_ = FALSE;
																_tmp63_ = x;
																_tmp64_ = neighbour;
																_tmp65_ = _tmp64_.x;
																nx = ((gint) _tmp63_) + _tmp65_;
																_tmp66_ = y;
																_tmp67_ = neighbour;
																_tmp68_ = _tmp67_.y;
																ny = ((gint) _tmp66_) + _tmp68_;
																_tmp70_ = nx;
																_tmp71_ = ny;
																_tmp72_ = minefield_is_location (self, _tmp70_, _tmp71_);
																if (_tmp72_) {
																	gint _tmp73_ = 0;
																	gint _tmp74_ = 0;
																	gboolean _tmp75_ = FALSE;
																	_tmp73_ = nx;
																	_tmp74_ = ny;
																	_tmp75_ = minefield_is_cleared (self, (guint) _tmp73_, (guint) _tmp74_);
																	_tmp69_ = !_tmp75_;
																} else {
																	_tmp69_ = FALSE;
																}
																_tmp76_ = _tmp69_;
																if (_tmp76_) {
																	gint _tmp77_ = 0;
																	gint _tmp78_ = 0;
																	gboolean _tmp79_ = FALSE;
																	gboolean _tmp80_ = FALSE;
																	gboolean _tmp83_ = FALSE;
																	_tmp77_ = nx;
																	_tmp78_ = ny;
																	minefield_clear_mine (self, (guint) _tmp77_, (guint) _tmp78_);
																	_tmp80_ = self->exploded;
																	if (_tmp80_) {
																		_tmp79_ = TRUE;
																	} else {
																		gboolean _tmp81_ = FALSE;
																		gboolean _tmp82_ = FALSE;
																		_tmp81_ = minefield_get_is_complete (self);
																		_tmp82_ = _tmp81_;
																		_tmp79_ = _tmp82_;
																	}
																	_tmp83_ = _tmp79_;
																	if (_tmp83_) {
																		return;
																	}
																}
															}
														}
													}
													has_change = TRUE;
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}


guint minefield_get_n_cleared (Minefield* self) {
	guint result;
	guint _tmp0_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->_n_cleared;
	result = _tmp0_;
	return result;
}


void minefield_set_n_cleared (Minefield* self, guint value) {
	guint _tmp0_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_n_cleared = _tmp0_;
}


gboolean minefield_get_is_complete (Minefield* self) {
	gboolean result;
	guint _tmp0_ = 0U;
	guint _tmp1_ = 0U;
	guint _tmp2_ = 0U;
	guint _tmp3_ = 0U;
	guint _tmp4_ = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = minefield_get_n_cleared (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->width;
	_tmp3_ = self->height;
	_tmp4_ = self->n_mines;
	result = _tmp1_ == ((_tmp2_ * _tmp3_) - _tmp4_);
	return result;
}


guint minefield_get_n_flags (Minefield* self) {
	guint result;
	guint _tmp0_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->_n_flags;
	result = _tmp0_;
	return result;
}


void minefield_set_n_flags (Minefield* self, guint value) {
	guint _tmp0_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_n_flags = _tmp0_;
}


gdouble minefield_get_elapsed (Minefield* self) {
	gdouble result;
	GTimer* _tmp0_ = NULL;
	gdouble _tmp1_ = 0.0;
	GTimer* _tmp2_ = NULL;
	gdouble _tmp3_ = 0.0;
	g_return_val_if_fail (self != NULL, 0.0);
	_tmp0_ = self->priv->clock;
	if (_tmp0_ == NULL) {
		result = 0.0;
		return result;
	}
	_tmp1_ = self->priv->clock_elapsed;
	_tmp2_ = self->priv->clock;
	_tmp3_ = g_timer_elapsed (_tmp2_, NULL);
	result = _tmp1_ + _tmp3_;
	return result;
}


gboolean minefield_get_paused (Minefield* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_paused;
	result = _tmp0_;
	return result;
}


void minefield_set_paused (Minefield* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp4_ = FALSE;
	GTimer* _tmp5_ = NULL;
	gboolean _tmp14_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp1_ = minefield_get_is_complete (self);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp3_ = FALSE;
		_tmp3_ = self->exploded;
		_tmp0_ = _tmp3_;
	}
	_tmp4_ = _tmp0_;
	if (_tmp4_) {
		return;
	}
	_tmp5_ = self->priv->clock;
	if (_tmp5_ != NULL) {
		gboolean _tmp6_ = FALSE;
		gboolean _tmp7_ = FALSE;
		gboolean _tmp9_ = FALSE;
		_tmp7_ = value;
		if (_tmp7_) {
			gboolean _tmp8_ = FALSE;
			_tmp8_ = self->priv->_paused;
			_tmp6_ = !_tmp8_;
		} else {
			_tmp6_ = FALSE;
		}
		_tmp9_ = _tmp6_;
		if (_tmp9_) {
			minefield_stop_clock (self);
		} else {
			gboolean _tmp10_ = FALSE;
			gboolean _tmp11_ = FALSE;
			gboolean _tmp13_ = FALSE;
			_tmp11_ = value;
			if (!_tmp11_) {
				gboolean _tmp12_ = FALSE;
				_tmp12_ = self->priv->_paused;
				_tmp10_ = _tmp12_;
			} else {
				_tmp10_ = FALSE;
			}
			_tmp13_ = _tmp10_;
			if (_tmp13_) {
				minefield_continue_clock (self);
			}
		}
	}
	_tmp14_ = value;
	self->priv->_paused = _tmp14_;
	g_signal_emit_by_name (self, "paused-changed");
}


static void g_cclosure_user_marshal_VOID__UINT_UINT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__UINT_UINT) (gpointer data1, guint arg_1, guint arg_2, gpointer data2);
	register GMarshalFunc_VOID__UINT_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__UINT_UINT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_uint (param_values + 1), g_value_get_uint (param_values + 2), data2);
}


static void value_minefield_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_minefield_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		minefield_unref (value->data[0].v_pointer);
	}
}


static void value_minefield_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = minefield_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_minefield_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_minefield_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Minefield* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = minefield_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_minefield_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Minefield** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = minefield_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_minefield (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecMinefield* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_MINEFIELD), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_minefield (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_MINEFIELD), NULL);
	return value->data[0].v_pointer;
}


void value_set_minefield (GValue* value, gpointer v_object) {
	Minefield* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_MINEFIELD));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_MINEFIELD));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		minefield_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		minefield_unref (old);
	}
}


void value_take_minefield (GValue* value, gpointer v_object) {
	Minefield* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_MINEFIELD));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_MINEFIELD));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		minefield_unref (old);
	}
}


static void minefield_class_init (MinefieldClass * klass) {
	minefield_parent_class = g_type_class_peek_parent (klass);
	MINEFIELD_CLASS (klass)->finalize = minefield_finalize;
	g_type_class_add_private (klass, sizeof (MinefieldPrivate));
	g_signal_new ("paused_changed", TYPE_MINEFIELD, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("tick", TYPE_MINEFIELD, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("redraw_sector", TYPE_MINEFIELD, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UINT_UINT, G_TYPE_NONE, 2, G_TYPE_UINT, G_TYPE_UINT);
	g_signal_new ("marks_changed", TYPE_MINEFIELD, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("explode", TYPE_MINEFIELD, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("cleared", TYPE_MINEFIELD, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void minefield_instance_init (Minefield * self) {
	self->priv = MINEFIELD_GET_PRIVATE (self);
	self->width = (guint) 0;
	self->height = (guint) 0;
	self->n_mines = (guint) 0;
	self->exploded = FALSE;
	self->priv->placed_mines = FALSE;
	self->priv->_n_cleared = (guint) 0;
	self->priv->_n_flags = (guint) 0;
	self->priv->_paused = FALSE;
	self->ref_count = 1;
}


static void minefield_finalize (Minefield* obj) {
	Minefield * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_MINEFIELD, Minefield);
	self->priv->locations = (_vala_array_free (self->priv->locations, self->priv->locations_length1 * self->priv->locations_length2, (GDestroyNotify) location_unref), NULL);
	_g_timer_destroy0 (self->priv->clock);
}


GType minefield_get_type (void) {
	static volatile gsize minefield_type_id__volatile = 0;
	if (g_once_init_enter (&minefield_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_minefield_init, value_minefield_free_value, value_minefield_copy_value, value_minefield_peek_pointer, "p", value_minefield_collect_value, "p", value_minefield_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (MinefieldClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) minefield_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Minefield), 0, (GInstanceInitFunc) minefield_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType minefield_type_id;
		minefield_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Minefield", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&minefield_type_id__volatile, minefield_type_id);
	}
	return minefield_type_id__volatile;
}


gpointer minefield_ref (gpointer instance) {
	Minefield* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void minefield_unref (gpointer instance) {
	Minefield* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		MINEFIELD_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



